<folder name="Santa">
  <service name="Sequencer" provision="sequencer"/>
  <service name="Santas" provision="expr">
    <prop content-type="text/x-erlang" name="expr.init.People"><![CDATA[
% The list of participants and the link to their private Slack channel. 
% See Slack docs on how to create an incoming webhook integration.
[
  {"Jacoby", "https://hooks.slack.com/services/..."},
  {"Yev", "https://hooks.slack.com/services/..."},
  {"Miklos", "https://hooks.slack.com/services/..."},
  {"Emily", "https://hooks.slack.com/services/..."},
  {"Mark", "https://hooks.slack.com/services/..."},
  {"Andrew", "https://hooks.slack.com/services/..."}
]
    ]]></prop>
    <prop MessagesSent="NewMessagesSent" Pairs="NewPairs" People="NewPeople" name="expr.state"/>
    <prop content-type="text/x-erlang" name="expr.init.Pairs"><![CDATA[
% List of giver/recipient pairs
[]
    ]]></prop>
    <prop MessagesSent="0" name="expr.init"/>
    <prop content-type="text/x-erlang" name="expr.src"><![CDATA[
% Put the elements of a list in random order
Shuffle =
  fun(L) ->
    [X||{_,X} <- lists:sort([ {rand:uniform(), N} || N <- L])]
  end,
 
% Expects a tuple accumulator: {prev, List} where prev is the previous list element
% Pairs up previous and current element and adds them to List
% Returns the current element as prev and the appended List
Iterate =
  fun (Elem, Acc) ->
      {Prev, List} = Acc,
      Pair = [Prev, Elem],
      {Elem, List ++ [Pair]}
  end,
  
% Shuffles the input list, and calls the Iterate function on all elements
% Initital accumulator is the last element of the list and an empty list
PairRandomly = 
  fun(List) ->
    ShuffledList = Shuffle(List),
    LastElem = lists:nth(length(List), ShuffledList),
    {AccOut, MyPairs} = lists:foldl(Iterate, {LastElem, []}, ShuffledList),
    MyPairs
  end.
    ]]></prop>
  </service>
  <field name="START"/>
  <field name="DONE"/>
  <field name="all_pairs" type="term"/>
  <field name="pairs_state" type="term"/>
  <field name="messages_sent" type="integer"/>
  <mix name="Mix">
    <notify fields="START" name="Start" service="Sequencer"/>
    <folder name="GetSanta">
      <request fields="START" name="FormPairs" service="Santas">
        <reply fields="all_pairs" name="Ok"/>
        <prop content-type="text/x-erlang" name="expr.src"><![CDATA[
% Pairs the participants randomly and updates the service state with the pairs
AllPairs = PairRandomly(People),
put("all_pairs", AllPairs),
NewPairs = AllPairs,
"Ok".
        ]]></prop>
      </request>
    </folder>
    <folder name="SendSanta">
      <service name="LibSlack" provision="subr">
        <prop key="lib.slack.Slack" name="subr.import"/>
      </service>
      <field name="url" type="string"/>
      <field name="heading" type="utf8"/>
      <field name="message" type="json"/>
      <field name="colour" type="utf8"/>
      <consume name="BuildMessage" service="Santas" fields="all_pairs">
        <reply name="Ok" fields="all_pairs colour heading message url"/>
        <reply name="Done" fields="DONE messages_sent pairs_state"/>
        <prop content-type="text/x-erlang" name="expr.src"><![CDATA[
% Recursively chunk list of giver/recipient pairs
% Extract names and giver's URL
PairsIn = get("all_pairs"),

case PairsIn of
  
  % If done with list, send end state values
  % reset states and send Done reply
  [] ->
    SentMessages = MessagesSent,
    put("messages_sent", SentMessages),
    NewMessagesSent = 0,
    PairsState = Pairs,
    put("pairs_state", PairsState),
    NewPairs = [],
    "Done";
  
  % Otherwise get first giver/recipient pair in list
  _Otherwise ->
    % And bind tail of list to output field
    [Pair|PairsOut] = PairsIn,
    put("all_pairs", PairsOut),
    
    % Divide it into giver and recipient
    [Giver,Recipient] = Pair,
    
    % Extract name and URL of giver and recipient
    % Message will be sent to Santa(GiverName)'s Slack channel(GiverUrl)
    {GiverName, GiverUrl} = Giver,
    {RecipientName, RecipientUrl} = Recipient,
    put("url", GiverUrl),
    % Build heading of Slack message
    Heading =  u("Hey " ++
                GiverName ++
                "! Please be Santa and buy a present for " ++
                RecipientName ++ "!"),
    put("heading", Heading),

    % Set colour theme of Slack message
    put("colour", "green"),

    % Build fields for Slack message
    Message = #{"To"=>u(RecipientName), "From"=>u(GiverName)},
    put("message", Message),
    NewMessagesSent = MessagesSent + 1,

    % Continue loop
    "Ok"
end.
        ]]></prop>
      </consume>
      <consume fields="colour heading message url" name="SendMessageUrl" service="LibSlack">
      </consume>
    </folder>
    <folder name="Test">
      <field name="test_url" type="string"/>
      <solicit fields="test_url" name="StartTest" service="Sequencer">
        <response fields="messages_sent pairs_state" name="Ok"/>
      </solicit>
      <request fields="test_url" name="SetUrls" service="Santas">
        <reply fields="START" name="Ok"/>
        <prop content-type="text/x-erlang" name="expr.src"><![CDATA[
% Set starting service states. All participants will get the same test URL, i.e. - all Slack messages are sent to this URL
NewPeople = [ setelement(2, X, get("test_url")) || X <- People],
"Ok".
        ]]></prop>
      </request>
    </folder>
  </mix>
</folder>